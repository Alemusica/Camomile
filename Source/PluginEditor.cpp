/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

Interface::Interface(Object const& object) : m_object(object)
{
    tuple<int, int> size = m_object.getSize();
    Component::setSize(std::get<0>(size), std::get<1>(size));
    Component::setVisible(true);
    Component::setInterceptsMouseClicks(m_object.wantMouse(), m_object.wantMouse());
    Component::setMouseClickGrabsKeyboardFocus(m_object.wantKeyboard());
    Component::setWantsKeyboardFocus(m_object.wantKeyboard());
}

void Interface::paint(Graphics& g)
{
    //DrawParameters parameters = m_object.getDrawParameters();
    //g.fillAll(parameters.getBackgroundColor());
    /*
     const std::tuple<int, t_elayer*> tup = m_object.paint();
     const int size = std::get<0>(tup);
     t_elayer* layers = std::get<1>(tup);
     if(size && layers)
     {
     AffineTransform transform(AffineTransform::translation(parameters.getBorderSize(), parameters.getBorderSize()));
     for(int i = 0; i < size; i++)
     {
     if(layers[i].e_state == EGRAPHICS_TODRAW)
     {
     for(int j = 0; j < layers[i].e_number_objects; j++)
     {
     t_egobj const& obj = layers[i].e_objects[j];
     const t_rgba color = hex_to_rgba(obj.e_color->s_name);
     g.setColour(toJuce(color));
     
     if(obj.e_type == E_GOBJ_PATH)
     {
     juce::Path path(toJuce(obj.e_npoints, obj.e_points));
     if(obj.e_filled)
     {
     g.fillPath(path, transform);
     }
     else
     {
     g.strokePath(path, PathStrokeType(obj.e_width), transform);
     }
     }
     else if(obj.e_type == E_GOBJ_RECT)
     {
     
     }
     else if(obj.e_type == E_GOBJ_TEXT)
     {
     g.drawText(juce::String(obj.e_text->s_name),
     obj.e_points[0].x,
     obj.e_points[0].y,
     obj.e_points[1].x,
     obj.e_points[1].y,
     juce::Justification(juce::Justification::centred), true);
     
     }
     }
     layers[i].e_state = EGRAPHICS_CLOSE;
     }
     
     }
     }
     */
    //g.setColour(parameters.getBorderColor());
    //g.drawRect(getBounds().withZeroOrigin(), parameters.getBorderSize());
}

void Interface::mouseMove(const MouseEvent& event)
{
    //m_object.mouseMove(event);
}

void Interface::mouseEnter(const MouseEvent& event)
{
    //m_object.mouseEnter(event);
}

void Interface::mouseExit(const MouseEvent& event)
{
    //m_object.mouseExit(event);
}

void Interface::mouseDown(const MouseEvent& event)
{
    //m_object.mouseDown(event);
}

void Interface::mouseDrag(const MouseEvent& event)
{
    //m_object.mouseDrag(event);
}

void Interface::mouseUp(const MouseEvent& event)
{
    //m_object.mouseUp(event);
}

void Interface::mouseDoubleClick(const MouseEvent& event)
{
    //m_object.mouseDoubleClick(event);
}

void Interface::mouseWheelMove(const MouseEvent& event, const MouseWheelDetails& wheel)
{
    //m_object.mouseWheelMove(event, wheel);
}

void Interface::redraw()
{
    const MessageManagerLock thread(Thread::getCurrentThread());
    if(thread.lockWasGained())
    {
        repaint();
    }
}

CamomileAudioProcessorEditor::CamomileAudioProcessorEditor(CamomileAudioProcessor& p) :
AudioProcessorEditor(&p),
m_processor(p),
m_file_drop(false)
{
    m_processor.addListener(this);
    shared_ptr<const Patcher> patch = m_processor.getPatch();
    if(patch)
    {
        const std::vector<Object> objects = patch->getObjects();
        for(auto it : objects)
        {
            m_objects.add(new Interface(it));
            addAndMakeVisible(m_objects.getLast());
        }
    }
    setSize(600, 400);
}

CamomileAudioProcessorEditor::~CamomileAudioProcessorEditor()
{
    m_processor.removeListener(this);
}

void CamomileAudioProcessorEditor::paint(Graphics& g)
{
    shared_ptr<const Patcher> patch = m_processor.getPatch();
    if(patch)
    {
        /*
        camo::Object cam = patch.getCamomile();
        camo::DrawParameters parameters = cam.getDrawParameters();
        g.fillAll(parameters.getBackgroundColor());
        g.setColour(parameters.getBorderColor());
         */
        g.drawRect(getBounds().withZeroOrigin());
    }
    else
    {
        g.fillAll(Colours::white);
        g.setColour(Colours::black);
        g.setFont (15.0f);
        g.drawText(juce::String("Drag & Drop your patch..."), getBounds().withZeroOrigin(), juce::Justification::centred);
    }
    
    if(m_file_drop)
    {
        g.fillAll(Colours::lightblue.withAlpha(0.2f));
    }
}

bool CamomileAudioProcessorEditor::isInterestedInFileDrag(const StringArray& files)
{
    if(files.size())
    {
        for(int i = 0; i < files.size(); i++)
        {
            if(files[i].endsWith(juce::StringRef(".pd")))
            {
                return true;
            }
        }
    }
    return false;
}

void CamomileAudioProcessorEditor::filesDropped(const StringArray& files, int x, int y)
{
    if(files.size())
    {
        for(int i = 0; i < files.size(); i++)
        {
            juce::File file(files[i]);
            if(file.getFileExtension() == juce::String(".pd"))
            {
                m_processor.loadPatch(file);
            }
        }
    }
}

void CamomileAudioProcessorEditor::patchChanged()
{
    removeAllChildren();
    m_objects.clear(true);
    shared_ptr<const Patcher> patch = m_processor.getPatch();
    if(patch)
    {
        const std::vector<Object> objects = patch->getObjects();
        for(auto it : objects)
        {
            m_objects.add(new Interface(it));
            addAndMakeVisible(m_objects.getLast());
        }
    }
    const MessageManagerLock mmLock;
    if(mmLock.lockWasGained())
    {
        repaint();
    }
}

void CamomileAudioProcessorEditor::fileDragEnter(const StringArray& files, int x, int y)
{
    const MessageManagerLock mmLock;
    if(mmLock.lockWasGained())
    {
        m_file_drop = true;
        repaint();
    }
}

void CamomileAudioProcessorEditor::fileDragExit(const StringArray& files)
{
    m_file_drop = false;
    repaint();
}

void CamomileAudioProcessorEditor::resized()
{
    
}
